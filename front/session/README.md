# <InternalPageTitle> O√π sauvegarder de l'info dans un browser ? </InternalPageTitle>

Nous avons vu qu'une des exigences associ√©es √† la cr√©ation d'une application selon l'architecture REST, c'est qu'elle soit **stateless** : l'API ne peut pas garder l'√©tat du client, sa session, c√¥t√© serveur.

C'est donc au client de sauvegarder ses donn√©es de session.

Mais o√π pouvons nous sauvegarder des donn√©es de mani√®re persistante c√¥t√© client ?

Il existe deux fa√ßons principales de sauvegarder de l'info dans un browser :
- le **web storage** ; 
- les **cookies**.

Dans le cadre de ce cours, nous allons principalement voir comment sauvegarder de l'info √† l'aide du **web storage**. Dans la partie du cours sur la gestion de l'authentification et l'autorisation d'utilisateurs, vous pourrez optionnellement voir comment les cookies peuvent √™tre utilis√©s pour sauvegarder des donn√©es de session c√¥t√© client.

NB : le browser met √† disposition d'autres API un peu moins connues pour sauvegarder des infos. Nous ne les verrons pas dans le cadre de ce cours, mais il reste n√©anmoins int√©ressant de lire tr√®s rapidement de quoi il s'agit :
- **IndexedDB API** : permet de sauvegarder c√¥t√© client de grandes quantit√©s d'infos structur√©es, incluant des fichiers ; c'est une base de donn√©es orient√©e objets en JS qui permet les transactions.
- **Cache API** : permet d'enregistrer et retrouver des requ√™tes et leur r√©ponses. Bien qu'√† la base cr√©√© pour pouvoir fournir des r√©ponses plus rapides √† certaines requ√™tes, cette API peut aussi √™tre utilis√©e comme m√©canisme g√©n√©ral de stockage.

# <InternalPageTitle> Persistance de donn√©es de session via le web storage </InternalPageTitle>

## Introduction
Le **Web Storage API** fournit un m√©canisme permettant aux browser d'enregistrer des paires **cl√© / valeur** d'une mani√®re plus intuitive que l'utilisation de cookies.

Il existe deux m√©canismes au sein du web storage :
- **sessionStorage** :
    - offre un espace de stockage s√©par√© pour chaque origine pour la dur√©e de la session d'une page, tant que le browser est ouvert.
    - les cl√©s / valeurs y sont enregistr√©es sous forme de string uniquement ;
    - met √† disposition un espace de stockage plus grand qu'un cookie, ~5MB maximum par origine ;
- **localStorage** : 
    - offre aussi un espace de stockage s√©par√© pour chaque origine, mais les donn√©es persistent quand le browser est ferm√© et r√©ouvert ;
    - est un espace de stockage plus grand qu'un cookie, limit√© √† ~10MB en cas de crash/restart du browser.

Les principales m√©thodes offertes par **sessionStorage** et **localStorage** sont les m√™mes. Voici quelques exemples de codes par m√©thode.

## `setItem()`
Cette m√©thode permet d'enregistrer, pour une cl√© donn√©e, la valeur associ√©e :

```ts numbered highlighting="5"
const¬†storeName¬†=¬†'user';

const¬†setUserSessionData¬†=¬†(user)¬†=>¬†{
¬†¬†const¬†storageValue¬†=¬†JSON.stringify(user);
¬†¬†localStorage.setItem(storeName,¬†storageValue);
};
```

Pour enregistrer un objet JS sous forme de string, il suffit de le s√©rialiser √† l'aide de la m√©thode `JSON.stringify()`.

## `getItem()`
Cette m√©thode permet d'obtenir la valeur associ√©e √† la cl√© donn√©e en argument :

```ts numbered highlighting="4"
const storeName =¬†'user';

const¬†getUserSessionData¬†=¬†()¬†=>¬†{
¬†¬†const¬†retrievedUser¬†=¬†localStorage.getItem(storeName);
¬†¬†if¬†(!retrievedUser)¬†return;
¬†¬†return¬†JSON.parse(retrievedUser);
};
```

Pour cet exemple, comme la valeur a √©t√© s√©rialis√©e, nous pouvons r√©cup√©rer l'objet gr√¢ce √† la m√©thode **`JSON.parse()`**.

## `removeITem()`
Cette m√©thode permet d'effacer une cl√© / valeur :

```js numbered highlighting="4"
const storeName =¬†'user';

const¬†removeSessionData¬†=¬†()¬†=>¬†{
¬†¬†localStorage.removeItem(storeName);
};
```

## `clear()`
Cette m√©thode permet d'effacer tout l'espace de stockage pour une origine donn√©e.

Cette m√©thode est tr√®s utile lorsque l'on souhaite effacer toute la session d'un utilisateur, notamment lors du logout d'un utilisateur.


# <InternalPageTitle> Exercice : persistence d'un th√®me (ex17) </InternalPageTitle>

Veuillez continuer l'exercice pr√©c√©dent nomm√© `/exercises/XY` afin de compl√©ter l'application `myMovies`.


Vous devez ajouter un moyen de switcher d'un th√®me "light" ou "dark" au sein de votre application. 

Par exemple, vous pouvez le faire via un bouton dans le header ou le footer permettant de basculer d'un th√®me √† l'autre.

Vous devez sauvegarder le th√®me s√©lectionn√© par l'utilisateur comme donn√©e de session persistante. Ainsi, vous allez sauvegarder l'information du th√®me dans le `localStorage`.

Au red√©marrage du browser, ou lors du refresh du frontend, l'application doit toujours afficher ses √©crans selon le dernier th√®me s√©lectionn√© : veuillez donc changer les couleurs de certains backgrounds et certains textes en fonction du th√®me.

Une fois tout fonctionel, veuillez faire un commit avec le message suivant : "new:exXY".

# <InternalPageTitle> Authentification d'un utilisateur via une IHM & JWT </InternalPageTitle>

Pour authentifier un utilisateur via une IHM, il suffit de faire une requ√™te √† une RESTful API.

G√©n√©ralement, l'utilisateur devra d'abord cr√©er son compte. Il utilisera un formulaire demandant au minimum un identifiant (username, adresse e-mail ou autres) et un password.  
Dans le cadre d'une SPA, l'IHM fera appel √† une op√©ration de type `register` lorsque l'utilisateur soumet le formulaire.

Par la suite, lorsque le compte de l'utilisateur existe, l'IHM fera appel √† une op√©ration de type `login` lorsque l'utilisateur tentera de se connecter √† l'aide d'un formulaire.

Dans les deux cas, `register` ou `login`, le d√©veloppeur devra conna√Ætre les op√©rations mises √† disposition par l'API. 

Dans le cadre du site de la pizzeria, nous savons que l'API met √† disposition ces deux op√©rations :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **`auths/login`** | **POST** | V√©rifier les credentials d'une ressource de type "users" et renvoyer le username et un token JWT si les credentials sont OK |
| **`auths/register`** | **POST** | Cr√©er une ressource de type "users" et renvoyer le username et un token JWT |

<br/>

Pour ce nouveau tutoriel, veuillez cr√©er un projet nomm√© `session-jwt` sur base du projet `fetch-proxy`.

Au sein de votre repo **`web2`**, veuillez cr√©er le projet nomm√© **`/web2/tutorials/pizzeria/hmi/jwt-fetch`** sur base d'un copi√©/coll√© de **`/web2/tutorials/pizzeria/hmi/async-await`** (ou [async-await-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/basic-fetch)).

Veuillez d√©marrer la version **`/web2/tutorials/pizzeria/api/safe`** de la RESTful API de la pizzeria. En cas de souci, vous pouvez utiliser ce code-ci :
[api-safe](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/safe).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**`/web2/tutorials/pizzeria/hmi/jwt-fetch`**.

Veuillez mettre √† jour le code de la **`RegisterPage`** afin de faire appel √† la m√©thode **`POST /auths/register`** et, si tout est OK, rediriger l'utilisateur vers la **`HomePage`** via la fonction **`Navigate`** :

```js numbered highlighting="2,34-63"
import { clearPage, renderPageTitle } from '../../utils/render';
import Navigate from '../Router/Navigate';

const RegisterPage = () => {
  clearPage();
  renderPageTitle('Register');
  renderRegisterForm();
};

function renderRegisterForm() {
  const main = document.querySelector('main');
  const form = document.createElement('form');
  form.className = 'p-5';
  const username = document.createElement('input');
  username.type = 'text';
  username.id = 'username';
  username.placeholder = 'username';
  username.required = true;
  username.className = 'form-control mb-3';
  const password = document.createElement('input');
  password.type = 'password';
  password.id = 'password';
  password.required = true;
  password.placeholder = 'password';
  password.className = 'form-control mb-3';
  const submit = document.createElement('input');
  submit.value = 'Register';
  submit.type = 'submit';
  submit.className = 'btn btn-danger';
  form.appendChild(username);
  form.appendChild(password);
  form.appendChild(submit);
  main.appendChild(form);
  form.addEventListener('submit', onRegister);
}

async function onRegister(e) {
  e.preventDefault();

  const username = document.querySelector('#username').value;
  const password = document.querySelector('#password').value;

  const options = {
    method: 'POST',
    body: JSON.stringify({
      username,
      password,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  };

  const response = await fetch('/api/auths/register', options);

  if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);

  const authenticatedUser = await response.json();

  console.log('Newly registered & authenticated user : ', authenticatedUser);

  Navigate('/');
}

export default RegisterPage;

```

Veuillez ex√©cuter le frontend et vous assurer que l'utilisateur que vous tentez de cr√©er est bien cr√©√© par votre API. Si tout fonctionne, vous aurez une confirmation dans la console de votre browser.

Bien, nous souhaitons pour l'instant sauvegarder **`authenticatedUser`** de mani√®re temporaire, car cet objet contient comme info le username et le token de l'utilisateur.

üí≠ Comment faire pour que cet objet soit disponible dans d'autres modules ?
Cette question nous permet d'explorer un propri√©t√© importante des **`export`** d'objets via ECMAScript : ce sont des objets immuables, c'est-√†-dire dont vous ne pouvez pas directement changer leurs valeurs. Comment faire alors pour offrir **`authenticatedUser`** ?  
Nous allons offrir quatre nouvelles fonctions : 
- une fonction qui renverra l'√©tat de la variable **`authenticatedUser`** ;
- une fonction qui permettra de modifier la variable **`authenticatedUser`** ;
- une fonction qui indiquera si l'utilisateur est authentifi√© ou pas ;
- une fonction qui permettra de faire un reset de l'utilisateur en cours (on utilisera cette fonction lors d'un logout).

Veuillez cr√©er le fichier **`/src/utils/auths.js`** et y ajouter le code suivant :

```js numbered
let currentUser;

const getAuthenticatedUser = () => currentUser;

const setAuthenticatedUser = (authenticatedUser) => {
  currentUser = authenticatedUser;
};

const isAuthenticated = () => currentUser !== undefined;

const clearAuthenticatedUser = () => {
  currentUser = undefined;
};

// eslint-disable-next-line object-curly-newline
export { getAuthenticatedUser, setAuthenticatedUser, isAuthenticated, clearAuthenticatedUser };
```

Veuillez mettre √† jour le code de la **`RegisterPage`** afin de sauver en m√©moire vive l'utilisateur authentifi√©. Nous allons aussi pr√©parer la suite afin d'avoir une **`Navbar`** qui s'adaptera lorsqu'un utilisateur est authentifi√©, c'est pourquoi nous allons appeler le composant **`Navbar`** :

```js numbered highlighting="1,3,66,68"
import { setAuthenticatedUser } from '../../utils/auths';
import { clearPage, renderPageTitle } from '../../utils/render';
import Navbar from '../Navbar/Navbar';
import Navigate from '../Router/Navigate';

const RegisterPage = () => {
  clearPage();
  renderPageTitle('Register');
  renderRegisterForm();
};

function renderRegisterForm() {
  const main = document.querySelector('main');
  const form = document.createElement('form');
  form.className = 'p-5';
  const username = document.createElement('input');
  username.type = 'text';
  username.id = 'username';
  username.placeholder = 'username';
  username.required = true;
  username.className = 'form-control mb-3';
  const password = document.createElement('input');
  password.type = 'password';
  password.id = 'password';
  password.required = true;
  password.placeholder = 'password';
  password.className = 'form-control mb-3';
  const submit = document.createElement('input');
  submit.value = 'Register';
  submit.type = 'submit';
  submit.className = 'btn btn-danger';
  form.appendChild(username);
  form.appendChild(password);
  form.appendChild(submit);
  main.appendChild(form);
  form.addEventListener('submit', onRegister);
}

async function onRegister(e) {
  e.preventDefault();

  const username = document.querySelector('#username').value;
  const password = document.querySelector('#password').value;

  const options = {
    method: 'POST',
    body: JSON.stringify({
      username,
      password,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  };

  const response = await fetch('/api/auths/register', options);

  if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);

  const authenticatedUser = await response.json();

  console.log('Newly registered & authenticated user : ', authenticatedUser);

  setAuthenticatedUser(authenticatedUser);

  Navbar();

  Navigate('/');
}

export default RegisterPage;
```

Pour la **`LoginPage`**, les modifications √† faire sont les m√™mes :

```js numbered highlighting="1,3-4,36-69"
import { setAuthenticatedUser } from '../../utils/auths';
import { clearPage, renderPageTitle } from '../../utils/render';
import Navbar from '../Navbar/Navbar';
import Navigate from '../Router/Navigate';

const LoginPage = () => {
  clearPage();
  renderPageTitle('Login');
  renderRegisterForm();
};

function renderRegisterForm() {
  const main = document.querySelector('main');
  const form = document.createElement('form');
  form.className = 'p-5';
  const username = document.createElement('input');
  username.type = 'text';
  username.id = 'username';
  username.placeholder = 'username';
  username.required = true;
  username.className = 'form-control mb-3';
  const password = document.createElement('input');
  password.type = 'password';
  password.id = 'password';
  password.required = true;
  password.placeholder = 'password';
  password.className = 'form-control mb-3';
  const submit = document.createElement('input');
  submit.value = 'Login';
  submit.type = 'submit';
  submit.className = 'btn btn-danger';
  form.appendChild(username);
  form.appendChild(password);
  form.appendChild(submit);
  main.appendChild(form);
  form.addEventListener('submit', onLogin);
}

async function onLogin(e) {
  e.preventDefault();

  const username = document.querySelector('#username').value;
  const password = document.querySelector('#password').value;

  const options = {
    method: 'POST',
    body: JSON.stringify({
      username,
      password,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  };

  const response = await fetch('/api/auths/login', options);

  if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);

  const authenticatedUser = await response.json();

  console.log('Authenticated user : ', authenticatedUser);

  setAuthenticatedUser(authenticatedUser);

  Navbar();

  Navigate('/');
}

export default LoginPage;
```

Nous souhaitons maintenant faire en sorte que la **`Navbar`** affiche des √©l√©ments diff√©rents si l'utilisateur est authentifi√© ou pas :
- s'il est authentifi√© : on affiche **`Home`**, **`Login`**, **`Register`** et le **`username`** de l'utilisateur connect√©.
- s'il est anonyme : on affiche **`Home`**, **`Add a pizza`**, **`Logout`**.

Nous allons mettre √† jour la **`Navbar`** pour s'adapter √† l'authentification d'un utilisateur :
```js
// eslint-disable-next-line no-unused-vars
import { Navbar as BootstrapNavbar } from 'bootstrap';
import { getAuthenticatedUser, isAuthenticated } from '../../utils/auths';

const Navbar = () => {
  renderNavbar();
};

function renderNavbar() {
  const authenticatedUser = getAuthenticatedUser();

  const anonymousUserNavbar = `
<nav class="navbar navbar-expand-lg navbar-light bg-danger">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">e-Pizzeria</a>
        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarSupportedContent"
          aria-controls="navbarSupportedContent"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item">
              <a class="nav-link active" aria-current="page" href="#" data-uri="/">Home</a>
            </li>
            <li id="loginItem" class="nav-item">
              <a class="nav-link" href="#" data-uri="/login">Login</a>
            </li>
            <li id="registerItem" class="nav-item">
              <a class="nav-link" href="#" data-uri="/register">Register</a>
            </li>            
          </ul>
        </div>
      </div>
    </nav>
`;

  const authenticatedUserNavbar = `
<nav class="navbar navbar-expand-lg navbar-light bg-danger">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">e-Pizzeria</a>
        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarSupportedContent"
          aria-controls="navbarSupportedContent"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item">
              <a class="nav-link active" aria-current="page" href="#" data-uri="/">Home</a>
            </li>          
            <li class="nav-item">
              <a class="nav-link" href="#" data-uri="/add-pizza">Add a pizza</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" data-uri="/logout">Logout</a>
            </li>    
            <li class="nav-item">
              <a class="nav-link disabled" href="#">${authenticatedUser?.username}</a>
            </li>           
          </ul>
        </div>
      </div>
    </nav>
`;

  const navbar = document.querySelector('#navbarWrapper');

  navbar.innerHTML = isAuthenticated() ? authenticatedUserNavbar : anonymousUserNavbar;
}

export default Navbar;
```

Ce code est quasi enti√®rement neuf. On a rajout√© l'√©l√©ment qui permettra de r√©aliser le logout d'un utilisateur. Avant d'aller plus loin, veuillez tester l'application.  
Loguez-vous avec l'utilisateur **`admin`** (et le password **`admin`**) et v√©rifiez que vous √™tes bien redirig√© vers la **`HomePage`** une fois authentifi√©, que la **`Navbar`** contient bien les √©l√©ments attendus, dont le **`username`**.  
Veuillez maintenant tester un clic sur l'√©l√©ment **`Add a pizza`** de la **`Navbar`**. Il ne se passe rien...  

üí≠ Pourquoi les clics ne sont plus pris en compte ?  
En fait, regardons le code de notre **`Router`**, pour la gestion des clics sur la **`Navbar`** :

```js
function onNavBarClick() {
  const navItems = document.querySelectorAll('.nav-link');

  navItems.forEach((item) => {
    item.addEventListener('click', (e) => {
      e.preventDefault();
      const uri = e.target?.dataset?.uri;
      const componentToRender = routes[uri];
      if (!componentToRender) throw Error(`The ${uri} ressource does not exist.`);

      componentToRender();
      window.history.pushState({}, '', uri);
    });
  });
}
```

Tant dans **`LoginPage`** que dans **`RegisterPage`**, nous faisons appel √† la fonction **`Navbar`** qui fait un "rerender" (r√©affichage) de la **`Navbar`**. Ainsi, tous les √©l√©ments de la barre de navigation sont "rerender", et donc comme le **`Router`** n'est pas r√©appel√©, la fonction **`onNavBarClick`** n'est pas r√©ex√©cut√©e. Ainsi, m√™me si les nouveaux √©l√©ments de la **`Navbar`** ont la classe CSS **`nav-link`**, leurs √©couteurs d'√©v√©nements de type **`click`** n'existent plus.

üí≠ Comment corriger cela ?  
On pourrait se dire qu'il suffit de faire appel √† la fonction **`onNavBarClick`** dans la **`Navbar`**. Cette solution ne fonctionnerait pas car nous aurions des d√©pendances cycliques, la **`Navbar`** devrait faire appel aux routes, qui elles font appel aux pages, les pages faisant appel √† la **`Navbar`**...  
D√®s lors, le mieux serait de mettre un √©couteur d'√©v√©nements au niveau du wrapper de la **`Navbar`**.  
Comme le wrapper n'est jamais r√©initialis√©, tout sera en ordre.  
Veuillez donc mettre √† jour la fonction **`onNavBarClick`** de **`/src/Components/Router/Router.js`** :

```js highlighting="2,4,6-8"
function onNavBarClick() {
  const navbarWrapper = document.querySelector('#navbarWrapper');

  navbarWrapper.addEventListener('click', (e) => {
    e.preventDefault();
    const navBarItemClicked = e.target;
    const uri = navBarItemClicked?.dataset?.uri;
    if (uri) {
      const componentToRender = routes[uri];
      if (!componentToRender) throw Error(`The ${uri} ressource does not exist.`);

      componentToRender();
      window.history.pushState({}, '', uri);
    }
  });
}
```

Veuillez noter que le **`navbarWrapper`** est initialis√© au sein du composant **`Header`**.  
Dans la nouvelle version du code du **`Router`**, le gestionnaire de clics est ajout√© au niveau de ce wrapper. Gr√¢ce √† l'event objet **`e`**, on acc√®de √† l'√©l√©ment sur lequel on a cliqu√© gr√¢ce √† la propri√©t√© **`target`**. On retrouve donc l'√©l√©ment de la navbar sur lequel on a cliqu√© tr√®s facilement. 

Veuillez tester votre IHM et v√©rifier qu'une fois logu√©, vous puissiez bien voyager entre les pages.

Il reste maintenant √† cr√©er un composant permettant de faire un logout. On souhaite que ce composant de logout supprime l'utilisateur authentifi√©, r√©affiche la **`Navbar`** pour un utilisateur anonyme et redirige l'utilisateur vers la page de login.

Pour ce faire, veuillez cr√©er le dossier et le fichier **`/src/Components/Logout/Logout.js`** et y ajouter ce code :
```js
import { clearAuthenticatedUser } from '../../utils/auths';
import Navbar from '../Navbar/Navbar';
import Navigate from '../Router/Navigate';

const Logout = () => {
  clearAuthenticatedUser();
  Navbar();
  Navigate('/login');
};

export default Logout;
```

Attention, m√™me si nous avons mis √† jour la **`Navbar`** et cr√©√© le composant **`Logout`**, le boilerplate du frontend impose de rajouter une route au sein du **`Router`** pour qu'un clic sur l'√©l√©ment **`Logout`** de la **`Navbar`** am√®ne √† appeler le composant **`Logout`**.
Veuillez donc mettre √† jour **`routes`** au sein de **`/src/Components/Router/Router.js`** :

```js highlighting="1,12"
import Logout from '../Logout/Logout';
import AddPizzaPage from '../Pages/AddPizzaPage';
import HomePage from '../Pages/HomePage';
import LoginPage from '../Pages/LoginPage';
import RegisterPage from '../Pages/RegisterPage';

const routes = {
  '/': HomePage,
  '/login': LoginPage,
  '/register': RegisterPage,
  '/add-pizza': AddPizzaPage,
  '/logout': Logout,
};
```

Veuillez maintenant tester le login et le logout. Tout devrait √™tre fonctionnel !  
Il nous reste √† faire en sorte que l'on puisse autoriser l'op√©ration de cr√©ation de pizza.

# <InternalPageTitle> Autorisation de l'appel √† une op√©ration prot√©g√©e  </InternalPageTitle>

Nous allons maintenant voir comment, √† partir d'une IHM, nous pouvons utiliser un token pour acc√©der √† une op√©ration d'une RESTful API.

Veuillez vous assurer que la version **`/web2/tutorials/pizzeria/api/safe`** de la RESTful API de la pizzeria est bien d√©marr√©e. En cas de souci, vous pouvez utiliser ce code-ci :
[api-safe](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/safe).

Veuillez vous connecter √† l'IHM du tutoriel en cours (**`/web2/tutorials/pizzeria/hmi/jwt-fetch`**) √† l'aide du compte **`manager`** et tentez d'ajouter une pizza. Cela ne devrait pas fonctionner.

Veuillez regarder dans la console : il devrait y avoir une erreur qui s'affiche avec le "status code" **`401 : Unauthorized`**.  
En effet, l'API attend un token pour autoriser l'op√©ration de cr√©ation d'une pizza.

Nous allons donc mettre √† jour **`/src/Components/Pages/AddPizzaPage.js`** pour ajouter le token de l'utilisateur authentifi√© au sein du header de la requ√™te (il n'y a que trois lignes √† rajouter) :

```js numbered highlighting="1,44,54"
import { getAuthenticatedUser } from '../../utils/auths';
import { clearPage, renderPageTitle } from '../../utils/render';
import Navigate from '../Router/Navigate';

const AddPizzaPage = () => {
  clearPage();
  renderPageTitle('Add a pizza to the menu');
  renderAddPizzaForm();
};

function renderAddPizzaForm() {
  const main = document.querySelector('main');
  const form = document.createElement('form');
  form.className = 'p-5';
  const title = document.createElement('input');
  title.type = 'text';
  title.id = 'title';
  title.placeholder = 'title of your pizza';
  title.required = true;
  title.className = 'form-control mb-3';
  const content = document.createElement('input');
  content.type = 'text';
  content.id = 'content';
  content.required = true;
  content.placeholder = 'Content of your pizza';
  content.className = 'form-control mb-3';
  const submit = document.createElement('input');
  submit.value = 'Add pizza to the menu';
  submit.type = 'submit';
  submit.className = 'btn btn-danger';
  form.appendChild(title);
  form.appendChild(content);
  form.appendChild(submit);
  main.appendChild(form);
  form.addEventListener('submit', onAddPizza);
}

async function onAddPizza(e) {
  e.preventDefault();

  const title = document.querySelector('#title').value;
  const content = document.querySelector('#content').value;

  const authenticatedUser = getAuthenticatedUser();

  const options = {
    method: 'POST',
    body: JSON.stringify({
      title,
      content,
    }),
    headers: {
      'Content-Type': 'application/json',
      Authorization: authenticatedUser.token,
    },
  };

  const response = await fetch('/api/pizzas', options);

  if (!response.ok) throw new Error(`fetch error : ${response.status} : ${response.statusText}`);

  const newPizza = await response.json();

  console.log('New pizza added : ', newPizza);

  Navigate('/');
}

export default AddPizzaPage;

```

Veuillez vous connecter √† l'IHM √† l'aide du compte **`manager`** et tenter d'ajouter une pizza. Cela ne devrait toujours pas fonctionner. Veuillez regarder dans la console : il devrait y avoir une erreur qui s'affiche avec le "status code" **`403 : Forbidden`**.  
En effet, l'API attend un token pour autoriser l'op√©ration de cr√©ation d'une pizza, mais seulement **`admin`** a le privil√®ge d'ajouter une pizza au menu !

D√©connectez-vous (logout), reconnectez-vous √† l'aide du compte **`admin`**, et ajoutez une pizza.
Voila ! Le site devrait √™tre enti√®rement fonctionnel !

Si tout fonctionne bien, faites un **`commit`** de votre repo (**`web2`**) avec comme message : **`jwt-fetch-hmi tutorial`**.

En cas de souci, vous pouvez utiliser le code du tutoriel :

- pour le frontend : [jwt-fetch-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/jwt-fetch).
- pour l'API : [api-safe](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/safe).

üí≠ Est-ce que c'est "safe" que notre IHM affiche le menu "Add a pizza" pour un utilisateur qui n'est pas l'admin ?    
*En fait oui, c'est "safe", vous l'avez test√©. L'API ne doit jamais faire confiance aux applications clientes pour appliquer la s√©curit√©. Ainsi, m√™me si le frontend autorise l'acc√®s √† des op√©rations qui ne devraient pas √™tre permises, au regard des autorisations appliqu√©es par l'API, √ßa n'a pas d'importance point de vue s√©curit√©.  
De la m√™me fa√ßon, c'est pour √ßa qu'une API doit aussi toujours valider les param√®tres qu'elle re√ßoit. Elle ne peut pas faire confiance aux applications clientes, comme par exemple √† une application web tournant dans un browser, pour valider tous les champs d'un formulaire.    
La raison est simple, l'API est d√©velopp√©e ind√©pendamment des applications clientes, elle ne peut pas supposer que les requ√™tes seront toujours bien construites.*

üí≠ OK, tout est "safe" si l'API fait toutes les v√©rifications n√©cessaires. N√©anmoins, n'y a-t-il pas des r√®gles de bonnes pratiques au niveau des IHM, pour ne pas permettre de faire n'importe quelles requ√™tes vers des API ?  
*Et bien oui, au niveau des IHM, pour des questions d'**ergonomie**, d'exp√©rience utilisateur, on va faire en sorte :*
- *de ne pas offrir des op√©rations qui ne seront pas autoris√©es. Par exemple, dans le cadre de ce tutoriel sur un site permettant de g√©rer une pizzeria, il ne faut pas "frustrer" les utilisateurs en leur faisant croire qu'ils ont acc√®s √† l'op√©ration de cr√©er une pizza ! Imaginez-vous, vous cr√©ez une nouvelle pizza de 32 ingr√©dients, et lors de la soumission, vous recevez un message comme quoi vous n'√™tes pas l'admin du site et que vous n'avez donc pas le droit de cr√©er une pizza üò≤!*
- *de ne pas demander du travail √† une API quand l'IHM peut d√©tecter que ce n'est pas utile. 
Ainsi, quand une IHM offre des formulaires, qui am√®neront √† des requ√™tes vers des API, on √©vitera d'autoriser la soumission des donn√©es tant que les champs n'ont pas √©t√© valid√©s. Tout ce que l'IHM peut valider c√¥t√© client, elle doit le faire. Le feedback sera plus rapide pour l'utilisateur, et les ressources de l'API seront √©conomis√©es (pas d'appel inutile).*

N'h√©sitez donc pas √† mettre √† jour ce tutoriel pour faire en sorte de n'afficher "Add a pizza" que si l'utilisateur est **`admin`**.

üí≠ Ca n'est pas un peu "cheap" que seul l'utilisateur **`admin`** puisse avoir le privil√®ge d'administrateur du site ?  
*H√© bien oui, c'est "cheap". G√©n√©ralement, dans le cadre d'applications plus robustes, nous allons ajouter un ou plusieurs r√¥le(s) aux utilisateurs. Par exemple, dans le cadre d'applications o√π les r√¥les sont simples, qu'il n'y a jamais qu'un seul r√¥le associ√© √† un utilisateur, il suffirait d'ajouter au niveau de l'API la propri√©t√© **`role`** aux utilisateurs. La majorit√© des utilisateurs pourrait avoir un r√¥le dont la valeur serait **`default`**, et une minorit√© d'utilisateur auraient le r√¥le d'**`admin`**...*

On n'affiche actuellement **pas de message d'erreur** √† l'utilisateur lorsque la r√©ponse d'une API renvoie une erreur. Pour am√©liorer l'exp√©rience de l'utilisateur, ce serait une am√©lioration √† faire.

Finalement, lorsqu'on ferme le browser et revient sur l'application par la suite, on n'est plus authentifi√©. Nous allons donc prochainement voir comment nous pourrions sauvegarder des donn√©es de session (le token et le username) c√¥t√©-client, dans le browser.

# <InternalPageTitle> Mise en place du localStorage pour sauvegarder les donn√©es de session </InternalPageTitle>

Dans le cadre du site nous permettant de g√©rer une pizzeria, nous allons faire en sorte de sauvegarder les donn√©es de session au sein du **`localStorage`**, et plus juste en m√©moire vive. Nous allons appliquer ce que nous avons appris dans la partie sur [Les sessions c√¥t√© client](../../part2/sessions/).

Veuillez d√©marrer la version **`/web2/tutorials/pizzeria/api/safe`** de la RESTful API de la pizzeria. En cas de souci, vous pouvez utiliser ce code-ci :
[api-safe](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/safe).

Pour ce nouveau tutoriel, au sein de votre repo **`web2`**, veuillez cr√©er le projet nomm√© **`/web2/tutorials/pizzeria/hmi/web-storage`** sur base d'un copier/coller de **`/web2/tutorials/pizzeria/hmi/jwt-fetch`** (ou [jwt-fetch-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/jwt-fetch)).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**`/web2/tutorials/pizzeria/hmi/web-storage`**.

Afin de sauvegarder les donn√©es de session, c'est √† dire l'objet **`authenticatedUser`** contenant un token et un username, nous devons juste mettre √† jour le fichier **`/usr/utils/auths.js`** :

```js numbered highlighting="1,7,10,15-16,24"
const STORE_NAME = 'user';
let currentUser;

const getAuthenticatedUser = () => {
  if (currentUser !== undefined) return currentUser;

  const serializedUser = localStorage.getItem(STORE_NAME);
  if (!serializedUser) return undefined;

  currentUser = JSON.parse(serializedUser);
  return currentUser;
};

const setAuthenticatedUser = (authenticatedUser) => {
  const serializedUser = JSON.stringify(authenticatedUser);
  localStorage.setItem(STORE_NAME, serializedUser);

  currentUser = authenticatedUser;
};

const isAuthenticated = () => currentUser !== undefined;

const clearAuthenticatedUser = () => {
  localStorage.removeItem(STORE_NAME);
  currentUser = undefined;
};

// eslint-disable-next-line object-curly-newline
export { getAuthenticatedUser, setAuthenticatedUser, isAuthenticated, clearAuthenticatedUser };
```

Au sein de **`getAuthenticatedUser`** : 
- on fait un premier check afin d'√©viter d'aller lire dans le **`localStorage`** si la variable **`currentUser`** est d√©j√† initialis√©e.
- on parse l'utilisateur authentifi√© et s√©rialis√© qui est retrouv√© dans le **`localStorage`** via la cl√© **`STORE_NAME`**.

Au sein de **`setAuthenticatedUser`**, on s√©rialise **`authenticatedUser`** avant d'ajouter une paire cl√©/valeur au **`localStorage`**.  Ces donn√©es restent dans le browser, peu importe le nombre de fois que l'on red√©marre son browser. 

Dans **`clearAuthenticatedUser`**, on efface la paire cl√©/valeur associ√©e √† l'utilisateur authentifi√© (via la cl√© **`STORE_NAME`**).

Veuillez bien mettre √† jour votre code et tester l'application.  
Connectez-vous √† l'aide de l'utilisateur **`manager`**.  Veuillez fermer votre browser.  
Veuillez le r√©ouvrir.   
Vous devriez automatiquement √™tre authentifi√© : veuillez observer l'√©tat de la **`Navbar`** pour vous en assurer.

üí≠ O√π puis-je observer l'√©tat des donn√©es sauvegard√©es dans le web storage de mon browser ?   
Tout en ayant la fen√™tre de votre application ouverte, via Chrome, allez dans vos outils de d√©veloppeurs : **`F12`**.  
Puis, dans l'onglet **`Application`**, vous trouverez dans **`Storage`** : **`Local Storage`** et **`Session Storage`**.  
Ici, nous utilisons le **`Local Storage`**, donc cliquez dessus, vous verrez appara√Ætre **`http://localhost:8080`**. Cliquez sur cette URL, et vous verrez vos donn√©es de session, quelque chose du style **`{"username":"manager","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Im1hbmFnZXIiLCJpYXQiOjE2NjE3NjM3MDksImV4cCI6MTc0ODE2MzcwOX0.jAxH0WsOgiK5vf4QduDZ8JgTR-SKC42G9aPieV_OTOo"}`**.  
N'h√©sitez pas √† faire un clic droit sur l'URL **`http://localhost:8080`**, puis **`Clear`**.  
Si vous faites ensuite un refresh de votre page, comme votre session aura √©t√© effac√©e, votre utilisateur ne sera plus connect√©. Votre **`Navbar`** affichera le menu pour un utilisateur anonyme !  
Faites ce test, c'est int√©ressant üòâ.

Si tout fonctionne bien, faites un **`commit`** de votre repo (**`web2`**) avec comme message :
**`web-storage-hmi tutorial`**.

En cas de souci, vous pouvez utiliser le code du tutoriel :

- pour le frontend : [web-storage-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/web-storage).
- pour l'API : [api-safe](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/safe).

# <InternalPageTitle> Projet 4.3 : Authentification et appel d'op√©rations prot√©g√©es par JWT </InternalPageTitle>

## Mise en place du projet

Vous devez mettre √† jour votre frontend afin qu'il consomme les nouvelles op√©rations de votre API qui ont √©t√© d√©velopp√©es pour [Projet 4.2](../security-api/#projet_4_2_securisation_d_api).

Le code de votre frontend doit se trouver dans votre repository local et votre web repository (normalement appel√© **`web2`**) dans le r√©pertoire nomm√© **`/project/4.3/hmi`** sur base d'un copier/coller du code de [Projet 3.1](../../part3/#projet_3_1_deploiement_de_votre_frontend_de_votre_backend).

## Authentification et appel d'op√©rations n√©cessitant une autorisation JWT

M√™me si votre projet ne n√©cessite pas d'authentification, afin d'apprendre les concepts associ√©s √† "JWT auths", veuillez cr√©er un prototype de frontend introduisant ces cas d'utilisation :
- **`register`** : les utilisateurs doivent pouvoir cr√©er un compte.
- **`login`** : les utilisateur doivent pouvoir se loguer.
- **`logout`** : les utilisateurs doivent pouvoir se d√©connecter.

<UnAuthenticatedBlock>

Si vous avez choisi comme projet d'approfondir le d√©veloppement de l'application **`myMovies`**, celle-ci doit maintenant autoriser les op√©rations suivantes que pour des utilisateurs authentifi√©s :
-	UC2 : l'ajout d'une ressource de type films via un formulaire d'ajout d'un film.
- UC3 : la suppression d'un film.
- UC4 : la mise √† jour des donn√©es d'un film (√† l'exception de l'id associ√© √† un film).

Comme auparavant, cette op√©ration est permise pour tous les utilisateurs, anonymes ou authentifi√©s :
-	UC1 : l'affichage, sous forme de tableau, de toutes les ressources de type films.

</UnAuthenticatedBlock>

Pensez √† bien mettre √† jour votre **`Navbar`** pour afficher les bons menus en fonction que l'utilisateur est authentifi√© ou pas.

Faites attention, il n'est pas autoris√©, pour des raisons d'ergonomie, que le frontend offre les fonctionnalit√©s d'√©criture de ressources pour les utilisateur non authentifi√©s. Vous devez donc rendre invisible les op√©rations non autoris√©es aux utilisateurs. 

<UnAuthenticatedBlock>

UC2 (create), UC3 (delete) et UC4 (update) doivent √™tre invisibles pour les utilisateurs anonymes.

</UnAuthenticatedBlock>

Dans un premier temps, veuillez faire en sorte de rajouter dans le web storage ces nouvelles donn√©es de session lors du login ou du register : le token et le username.  
NB : pr√©c√©demment vous aviez des donn√©es de session √† g√©rer pour le th√®me et pour un message concernant le respect de la vie priv√©e.

<AuthenticatedBlock>

Veuillez travailler avec les membres de votre groupe et vous partager le travail :
- certains membres peuvent travailler sur le frontend ;
- d'autres membres peuvent travailler sur le backend s'il vous reste des op√©rations √† rajouter.

Un peu avant la fin de la s√©ance, veuillez discuter :
- pr√©senter ce que vous avez appris au niveau de la s√©curisation aux membres qui ont travaill√© sur autre chose.

</AuthenticatedBlock>

Quand votre prototype de frontend offre l'authentification (register & login) et utilise toutes les op√©rations s√©curis√©es de votre API, que les sessions sont bien sauvegard√©es, veuillez faire un **`commit`** de votre code avec comme message : **`4.3.1 : hmi jwt auths`**.

#### ü§ù Tips

- N'h√©sitez pas √† copier/coller les fichiers utiles trouv√©s dans le tutoriel associ√© √† cette partie : **`RegisterPage`**, **`LoginPage`**, **`Logout`**, **`auths`**, **`Navbar`** (diff√©rent affichage pour un utilisateur anonyme que pour un utilisateur connect√©)....
- Attention √† ne pas oublier de mettre √† jour votre **`Router`** : nouvelles pages pour le register, le login et le logout, la Navbar...
- Ajoutez les tokens dans le header de vos requ√™tes **`fetch`**... 
- Concernant le **`Router`**, il faut mettre √† jour **`onNavBarClick`** pour que les gestionnaires d'ev√©n√©ments restent attach√©s m√™me quand la **`Navbar`** est r√©affich√©e.
- üí≠ Comment rendre invisible les op√©rations d'√©criture de certaines ressources au sein du frontend ?  
Par exemple, vous pourriez afficher des boutons de type **`Delete`** ou **`Save`** que si l'utilisateur est authentifi√©.  
De m√™me, si l'utilisateur est anonyme, les ressources ne devraient pas √™tre √©ditables.

## üç¨ Gestion de session & remember me

Vous pourriez ajouter une fonction "remember me" √† votre formulaire de "login" et de "register" et faire en sorte que vos donn√©es de session soient sauvegard√©es :
- dans le **`localStorage`** si l'on clique sur une checkbox "Remember me" ;
- dans le **`sessionStorage`** si l'on ne clique pas sur la checkbox "Remember me" lors du login ou du register.


Quand votre prototype de frontend est finalis√©, veuillez faire un **`commit`** de votre code avec comme message : **`4.3.2 : remember me`**.


#### ü§ù Tips
- Vous allez pouvoir refaire un peu de gestion d'√©v√©nements pour d√©tecter les clics sur une checkbox. N'h√©sitez pas √† voir ce que propose **Bootstrap 5** pour les **checkboxes**.
- Prenez un moment pour voir comment g√©rer la persistance de l'info 'Remember me'...  
Est-ce que ce n'est pas une donn√©e de session qui doit persister lorsque l'utilisateur ferme son browser ?  
En effet, point de vue ergonomie, il est int√©ressant que le dernier choix de l'utilisateur soit toujours pr√©sent√©. La checkbox devrait donc rester **`checked`** ou pas, tant que l'utilisateur ne change pas son √©tat, via un clic, ou via un Logout ; et cet √©tat doit subsister aux travers des connexions (ouvertures / fermetures du browser).


# <InternalPageTitle> üç¨ Persistance de donn√©es de session via des cookies </InternalPageTitle>

## Authentification & autorisation JWT √† l'aide de cookies

Dans la partie optionnelle sur l'[Authentification & autorisation JWT √† l'aide de cookies](../security-api/#üç¨_authentification_autorisation_jwt_a_laide_de_cookies), nous avons vu comment mettre √† jour l'API afin d'int√©grer les tokens JWT aux cookies.

Veuillez d√©marrer la version **`/web2/tutorials/pizzeria/api/cookies`** de la RESTful API de la pizzeria. En cas de souci, vous pouvez utiliser ce code-ci :
[api-cookies](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/cookies).

Nous allons voir maintenant comment le frontend peut utiliser ces cookies.

## Gestion de session c√¥t√© client via une IHM et des cookies

Pour ce nouveau tutoriel, nous allons repartir de la derni√®re version de notre frontend.

Au sein de votre repo **`web2`**, veuillez cr√©er le projet nomm√© **`/web2/tutorials/pizzeria/hmi/cookies`** sur base d'un copi√©/coll√© de **`/web2/tutorials/pizzeria/hmi/web-storage`** (ou [web-storage-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/web-storage)).

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**`/web2/tutorials/pizzeria/hmi/cookies`**.

Afin de sauvegarder les donn√©es de session, c'est √† dire l'objet **`authenticatedUser`** contenant juste un username, nous ne devons m√™me pas mettre √† jour le fichier **`/usr/utils/auths.js`**. En effet, l'API **`cookies`** renvoie un objet du genre **`{username: "manager"}`**. Au niveau de l'IHM, le code est donc toujours fonctionnel pour sauvegarder le username gr√¢ce √† `authenticatedUser`.

Il ne reste donc qu'√† changer le code o√π nous avons besoin d'une autorisation. Pour l'application de gestion de la pizzeria, il s'agit de la cr√©ation de pizza.  
Veuillez donc mettre √† jour **`/src/Components/AddPizzaPage.js`** en enlevant ces deux lignes :
- l'authenticatedUser : **`const authenticatedUser = getAuthenticatedUser();`** et l'import associ√© (**`import { getAuthenticatedUser } from '../../utils/auths';`**),
- la ligne s'occupant de l'authorization header : **`Authorization: authenticatedUser.token`**.

Veuillez tester votre derni√®re version du frontend.
Loguez-vous avec l'utilisateur **`admin`** (et le password **`admin`**).  
Ajoutez une pizza et v√©rifiez qu'elle s'affiche bien.  

üí≠ Comment v√©rifier le cookie ?  
Tout en ayant la fen√™tre de votre application ouverte, via Chrome, allez dans vos outils de d√©veloppeurs : **`F12`**.  
Puis, dans l'onglet **`Application`**, cliquez sur **`Cookies`**, vous verrez appara√Ætre **`http://localhost:8080`**. Cliquez sur cette URL, et vous verrez vos 2 cookies de session, **`user.sig`** et **`user`**.  
N'h√©sitez pas √† aller d√©coder la valeur du cookie **`user`** sur [base64decode](https://www.base64decode.org/) en faisant un copier / coller de **`Value`**. Vous devriez voir quelque chose appara√Ætre du style **`{"username":"manager","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Im1hbmFnZXIiLCJpYXQiOjE2NjE3NzUxMDgsImV4cCI6MTc0ODE3NTEwOH0.sAZqq6vbrjCCZZoLH-n8hJKBoXJJJ8jEoupk8xKu5WI"}`**  !

Toujours dans l'onglet **`Application`** des outils de d√©veloppeurs de Chrome, faites un clear des cookies : clic droit sur **`http://localhost:8080`**, **`Clear`**.  
Tentez maintenant d'ajouter une pizza... Ca ne fonctionne plus, et c'est bien normal, car il n'y a plus de token qui est envoy√© √† l'API !  

Suite √† ces tests, si tout fonctionne bien, faites un **`commit`** de votre repo (**`web2`**) avec comme message : **`cookies-hmi tutorial`**.

En cas de souci, vous pouvez utiliser le code du tutoriel :

- pour le frontend : [cookies-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/cookies).
- pour l'API : [api-cookies](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/restful-api-essentials/cookies).

üí≠ Notons que cette version de notre frontend pourrait √™tre am√©lior√©e. Actuellement, lorsqu'on fait un logout, on n'efface pas le cookie du browser.   
Comment feriez vous ?  
*Vous pourriez par exemple appeler la m√©thode **`GET /auths/logout`** üòâ.*
